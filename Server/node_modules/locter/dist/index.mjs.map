{"version":3,"file":"index.mjs","sources":["../src/utils/has-property.ts","../src/utils/object.ts","../src/utils/error.ts","../src/utils/file-name.ts","../src/utils/to-array.ts","../src/utils/file-path.ts","../src/utils/runtime.ts","../src/utils/typescript.ts","../src/locator/utils.ts","../src/locator/async.ts","../src/locator/sync.ts","../src/loader/built-in/conf/module.ts","../src/loader/built-in/module/utils.ts","../src/loader/built-in/module/module.ts","../src/loader/built-in/json/module.ts","../src/loader/built-in/yaml/module.ts","../src/loader/constants.ts","../src/loader/module.ts","../src/loader/singleton.ts","../src/loader/helpers.ts"],"sourcesContent":["export function hasOwnProperty<X extends Record<string, any>, Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, unknown> {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport function hasStringProperty<X extends Record<string, any>, Y extends PropertyKey>(obj: X, prop: Y): obj is X & Record<Y, string> {\n    return hasOwnProperty(obj, prop) && typeof obj[prop] === 'string';\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isObject(item: unknown) : item is Record<string, any> {\n    return (\n        !!item &&\n        typeof item === 'object' &&\n        !Array.isArray(item)\n    );\n}\n\nexport function isSafeObjectKey(key: string) : boolean {\n    return key !== '__proto__' &&\n        key !== 'prototype' &&\n        key !== 'constructor';\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { hasOwnProperty } from './has-property';\nimport { isObject } from './object';\n\nexport function handleException(e: unknown) : void {\n    if (e instanceof Error) {\n        throw e;\n    }\n\n    const error = new Error('Can not process thrown exception.');\n\n    if (isObject(e)) {\n        if (\n            hasOwnProperty(e, 'message') &&\n            typeof e.message === 'string'\n        ) {\n            error.message = e.message;\n        }\n\n        if (\n            hasOwnProperty(e, 'stack') &&\n            typeof e.stack === 'string'\n        ) {\n            error.stack = e.stack;\n        }\n    }\n\n    throw error;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport path from 'node:path';\n\nexport function getFileNameExtension(\n    input: string,\n    allowed?: string[],\n) : string | undefined {\n    const extension = path.extname(input);\n    if (extension === '' || extension === '.') {\n        return undefined;\n    }\n\n    if (\n        typeof allowed === 'undefined' ||\n        allowed.indexOf(extension) !== -1\n    ) {\n        return extension;\n    }\n\n    return undefined;\n}\n\nexport function removeFileNameExtension(\n    input: string,\n    extensions?: string[],\n) {\n    const extension = getFileNameExtension(input, extensions);\n    if (extension) {\n        return input.substring(0, input.length - extension.length);\n    }\n\n    return input;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function toArray(input: string | string[]) : string[] {\n    return Array.isArray(input) ? input : [input];\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\nimport path from 'node:path';\n\nexport function isFilePath(input: string) {\n    const extension = path.extname(input);\n    return extension && extension !== '';\n}\n","/*\n * Copyright (c) 2024.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport function isJestRuntimeEnvironment() : boolean {\n    return process.env &&\n        process.env.JEST_WORKER_ID !== undefined;\n}\n\nexport function isTsNodeRuntimeEnvironment(): boolean {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return !!process[Symbol.for('ts-node.register.instance')];\n}\n","/*\n * Copyright (c) 2024.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { isObject } from './object';\n\nexport function isTypeScriptError(input: unknown) : input is Error {\n    if (!isObject(input)) {\n        return false;\n    }\n\n    if (typeof input.diagnosticCodes !== 'undefined') {\n        return true;\n    }\n\n    return typeof input.message === 'string' &&\n        /TS\\d+/.test(input.message);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport path from 'node:path';\nimport { isObject, toArray } from '../utils';\nimport type { LocatorInfo, LocatorOptions, LocatorOptionsInput } from './types';\n\nexport function buildLocatorPatterns(pattern: string | string[]) : string[] {\n    return Array.isArray(pattern) ?\n        pattern :\n        [pattern];\n}\n\nexport function buildLocatorOptions(options: LocatorOptionsInput = {}) : LocatorOptions {\n    const paths = options.path ?\n        toArray(options.path) :\n        [];\n\n    const ignore = options.ignore ?\n        toArray(options.ignore) :\n        [];\n\n    if (paths.length === 0) {\n        paths.push(process.cwd());\n    }\n\n    let onlyFiles : boolean;\n    let onlyDirectories : boolean;\n\n    if (options.onlyDirectories === options.onlyFiles) {\n        onlyDirectories = false;\n        onlyFiles = !options.onlyDirectories;\n    } else if (typeof options.onlyFiles === 'undefined') {\n        onlyDirectories = options.onlyDirectories ?? false;\n        onlyFiles = !options.onlyDirectories;\n    } else {\n        onlyFiles = options.onlyFiles ?? true;\n        onlyDirectories = !options.onlyFiles;\n    }\n\n    return {\n        path: paths,\n        ignore,\n        onlyDirectories,\n        onlyFiles,\n    };\n}\n\nexport function pathToLocatorInfo(\n    input: string,\n    skipResolve?: boolean,\n) : LocatorInfo {\n    if (\n        !skipResolve &&\n        !path.isAbsolute(input)\n    ) {\n        input = path.resolve(process.cwd(), input);\n    }\n\n    const info = path.parse(input);\n\n    return {\n        path: info.dir.split('/').join(path.sep),\n        name: info.name,\n        extension: info.ext ?\n            info.ext :\n            undefined,\n    };\n}\n\nexport function isLocatorInfo(\n    input: unknown,\n) : input is LocatorInfo {\n    return isObject(input) &&\n        typeof input.path === 'string' &&\n        typeof input.name === 'string' &&\n        typeof input.extension === 'string';\n}\n\nexport function buildFilePath(input: LocatorInfo | string) {\n    if (typeof input === 'string') {\n        return input;\n    }\n\n    if (input.extension) {\n        return path.join(input.path, input.name) + input.extension;\n    }\n\n    return path.join(input.path, input.name);\n}\n\nexport function buildFilePathWithoutExtension(input: LocatorInfo | string) {\n    let info: LocatorInfo;\n\n    if (typeof input === 'string') {\n        info = pathToLocatorInfo(input);\n    } else {\n        info = input;\n    }\n\n    return path.join(info.path, info.name);\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport fg from 'fast-glob';\nimport type { LocatorInfo, LocatorOptionsInput } from './types';\nimport { buildLocatorOptions, buildLocatorPatterns, pathToLocatorInfo } from './utils';\n\nexport async function locateMany(\n    pattern: string | string[],\n    options?: LocatorOptionsInput,\n) : Promise<LocatorInfo[]> {\n    const patterns = buildLocatorPatterns(pattern);\n    const opts = buildLocatorOptions(options);\n\n    const items : LocatorInfo[] = [];\n\n    for (let i = 0; i < patterns.length; i++) {\n        for (let j = 0; j < opts.path.length; j++) {\n            const files = await fg(patterns[i], {\n                absolute: true,\n                cwd: opts.path[j],\n                ignore: opts.ignore,\n                onlyFiles: opts.onlyFiles,\n                onlyDirectories: opts.onlyDirectories,\n            });\n\n            for (let k = 0; k < files.length; k++) {\n                items.push(pathToLocatorInfo(files[k], true));\n            }\n        }\n    }\n\n    return items;\n}\n\nexport async function locate(\n    pattern: string | string[],\n    options?: LocatorOptionsInput,\n) : Promise<LocatorInfo | undefined> {\n    const patterns = buildLocatorPatterns(pattern);\n    const opts = buildLocatorOptions(options);\n\n    for (let i = 0; i < patterns.length; i++) {\n        for (let j = 0; j < opts.path.length; j++) {\n            const files = await fg(patterns[i], {\n                absolute: true,\n                cwd: opts.path[j],\n                ignore: opts.ignore,\n                onlyFiles: opts.onlyFiles,\n                onlyDirectories: opts.onlyDirectories,\n            });\n\n            const element = files.shift();\n            if (element) {\n                return pathToLocatorInfo(element, true);\n            }\n        }\n    }\n\n    return undefined;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport fg from 'fast-glob';\nimport type { LocatorInfo, LocatorOptionsInput } from './types';\nimport { buildLocatorOptions, buildLocatorPatterns, pathToLocatorInfo } from './utils';\n\nexport function locateManySync(\n    pattern: string | string[],\n    options?: LocatorOptionsInput,\n) : LocatorInfo[] {\n    const patterns = buildLocatorPatterns(pattern);\n    const opts = buildLocatorOptions(options);\n\n    const items : LocatorInfo[] = [];\n\n    for (let i = 0; i < patterns.length; i++) {\n        for (let j = 0; j < opts.path.length; j++) {\n            const files = fg.sync(patterns[i], {\n                absolute: true,\n                cwd: opts.path[j],\n                ignore: opts.ignore,\n                onlyFiles: opts.onlyFiles,\n                onlyDirectories: opts.onlyDirectories,\n            });\n\n            for (let k = 0; k < files.length; k++) {\n                items.push(pathToLocatorInfo(files[k], true));\n            }\n        }\n    }\n\n    return items;\n}\n\nexport function locateSync(\n    pattern: string | string[],\n    options?: LocatorOptionsInput,\n) : LocatorInfo | undefined {\n    const patterns = buildLocatorPatterns(pattern);\n    const opts = buildLocatorOptions(options);\n\n    for (let i = 0; i < patterns.length; i++) {\n        for (let j = 0; j < opts.path.length; j++) {\n            const files = fg.sync(patterns[i] as string, {\n                absolute: true,\n                cwd: opts.path[j],\n                ignore: opts.ignore,\n                onlyFiles: opts.onlyFiles,\n                onlyDirectories: opts.onlyDirectories,\n            });\n\n            const element = files.shift();\n            if (element) {\n                return pathToLocatorInfo(element, true);\n            }\n        }\n    }\n\n    return undefined;\n}\n","/*\n * Copyright (c) 2022-2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\n// Based on https://github.com/unjs/rc9 (MIT)\n\nimport { destr } from 'destr';\nimport flat from 'flat';\nimport fs from 'node:fs';\nimport { buildFilePath } from '../../../locator';\nimport { handleException, isSafeObjectKey } from '../../../utils';\nimport type { Loader } from '../../type';\n\nexport class ConfLoader implements Loader {\n    async execute(input: string) {\n        const filePath = buildFilePath(input);\n\n        try {\n            const file = await fs.promises.readFile(filePath, { encoding: 'utf-8' });\n\n            return this.parse(file);\n        } catch (e) {\n            return handleException(e);\n        }\n    }\n\n    executeSync(input: string) {\n        const filePath = buildFilePath(input);\n\n        try {\n            const file = fs.readFileSync(filePath, { encoding: 'utf-8' });\n\n            return this.parse(file);\n        } catch (e) {\n            return handleException(e);\n        }\n    }\n\n    parse(contents: string): Record<string, any> {\n        const config: Record<string, any> = {};\n\n        const lines = contents.split(/\\n|\\r|\\r\\n/);\n\n        for (let i = 0; i < lines.length; i++) {\n            const match = lines[i].match(/^\\s*([^\\s=]+)\\s*=\\s*(.*)?\\s*$/);\n            if (!match) {\n                continue;\n            }\n\n            // Key\n            const key = match[1];\n\n            if (!key || !isSafeObjectKey(key)) {\n                continue;\n            }\n\n            const value = destr(match[2].trim() /* val */);\n\n            if (key.endsWith('[]')) {\n                const arrKey = key.slice(0, Math.max(0, key.length - 2));\n                config[arrKey] = (config[arrKey] || []).concat(value);\n                continue;\n            }\n\n            config[key] = value;\n        }\n\n        return flat.unflatten(config, { overwrite: true });\n    }\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { hasOwnProperty, isObject } from '../../../utils';\nimport type { LoaderFilterFn, ModuleExport } from './type';\n\ntype ESModule = { [key: string]: any, __esModule: boolean };\nexport function isESModule(input: unknown) : input is ESModule {\n    return isObject(input) &&\n        // eslint-disable-next-line no-underscore-dangle\n        typeof input.__esModule !== 'undefined';\n}\n\n// https://2ality.com/2017/01/babel-esm-spec-mode.html\nexport function toModuleRecord(\n    data: unknown,\n) {\n    if (isESModule(data)) {\n        // @see https://github.com/testing-library/user-event/issues/813\n        // @see https://stackoverflow.com/questions/62717394/export-default-class-exports-double-nested-default\n        if (\n            isESModule(data.default) &&\n            data.default.default\n        ) {\n            return {\n                ...data,\n                default: data.default.default,\n            };\n        }\n\n        return data;\n    }\n\n    const output = Object.create(null, {\n        __esModule: {\n            value: true,\n        },\n        [Symbol.toStringTag]: {\n            value: 'Module',\n        },\n    });\n\n    if (isObject(data)) {\n        // eslint-disable-next-line no-restricted-syntax\n        for (const key in data) {\n            if (hasOwnProperty(output, key)) {\n                continue;\n            }\n\n            let descriptor = Object.getOwnPropertyDescriptor(data, key);\n            if (\n                !descriptor ||\n                ('get' in descriptor || descriptor.writable || descriptor.configurable)\n            ) {\n                descriptor = {\n                    enumerable: true,\n                    get() {\n                        return data[key];\n                    },\n                };\n            }\n\n            Object.defineProperty(output, key, descriptor);\n        }\n    }\n\n    if (!hasOwnProperty(output, 'default')) {\n        Object.defineProperty(output, 'default', {\n            value: data,\n            enumerable: true,\n        });\n    }\n\n    return Object.freeze(output);\n}\n\nexport function getModuleExport(\n    data: Record<string, any>,\n    filterFn: LoaderFilterFn,\n): ModuleExport | undefined {\n    const keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n        if (filterFn(keys[i] as string, data[keys[i] as string])) {\n            return {\n                key: keys[i] as string,\n                value: data[keys[i] as string],\n            };\n        }\n    }\n\n    return undefined;\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { BaseError } from 'ebec';\nimport { createJiti } from 'jiti';\nimport { pathToFileURL } from 'node:url';\nimport type { LocatorInfo } from '../../../locator';\nimport {\n    buildFilePath,\n    isLocatorInfo,\n} from '../../../locator';\nimport {\n    handleException,\n    hasStringProperty,\n    isFilePath, isJestRuntimeEnvironment,\n    isObject,\n    isTsNodeRuntimeEnvironment,\n    isTypeScriptError,\n} from '../../../utils';\nimport type { Loader } from '../../type';\nimport type { ModuleLoadOptions } from './type';\nimport { toModuleRecord } from './utils';\n\ntype Jiti = ReturnType<typeof createJiti>;\n\nexport class ModuleLoader implements Loader {\n    protected instance : Jiti;\n\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        this.instance = createJiti(undefined, {\n            extensions: ['.js', '.mjs', '.mts', '.cjs', '.cts', '.ts'],\n        });\n    }\n\n    async execute(input: string) {\n        let output : any;\n\n        try {\n            output = await this.load(input);\n        } catch (e) {\n            if (\n                e instanceof SyntaxError ||\n                e instanceof ReferenceError ||\n                isTypeScriptError(e)\n            ) {\n                throw e;\n            }\n\n            // jiti + ts-node\n            // issue: https://github.com/nuxt/bridge/issues/228\n            if (isTsNodeRuntimeEnvironment()) {\n                output = this.loadSync(input);\n            } else {\n                output = this.instance(input);\n            }\n        }\n\n        return toModuleRecord(output);\n    }\n\n    executeSync(input: string) {\n        let output : any;\n\n        try {\n            output = this.loadSync(input);\n        } catch (e) {\n            if (\n                e instanceof SyntaxError ||\n                e instanceof ReferenceError ||\n                isTypeScriptError(e)\n            ) {\n                throw e;\n            }\n\n            output = this.instance(input);\n        }\n\n        return toModuleRecord(output);\n    }\n\n    // ---------------------------------------------------------------------------\n\n    async load(\n        data: LocatorInfo | string,\n        options: ModuleLoadOptions = {},\n    ) : Promise<unknown> {\n        const id = this.build(data, options);\n\n        try {\n            // segmentation fault\n            // issue: https://github.com/nodejs/node/issues/35889\n            if (isJestRuntimeEnvironment()) {\n                // eslint-disable-next-line global-require,import/no-dynamic-require\n                return require(id);\n            }\n\n            return await import(id);\n        } catch (e) {\n            /* istanbul ignore next */\n            if (\n                isObject(e) &&\n                hasStringProperty(e, 'code')\n            ) {\n                if (\n                    !options.withFilePrefix &&\n                    (\n                        e.code === 'ERR_UNSUPPORTED_ESM_URL_SCHEME' ||\n                        e.code === 'UNSUPPORTED_ESM_URL_SCHEME'\n                    )\n                ) {\n                    return this.load(data, {\n                        ...options,\n                        withFilePrefix: true,\n                    });\n                }\n\n                throw new BaseError({\n                    code: e.code,\n                    message: hasStringProperty(e, 'message') ? e.message : undefined,\n                    stack: hasStringProperty(e, 'stack') ? e.stack : undefined,\n                });\n            }\n\n            /* istanbul ignore next */\n            return handleException(e);\n        }\n    }\n\n    loadSync(\n        data: LocatorInfo | string,\n        options: ModuleLoadOptions = {},\n    ) : unknown {\n        const id = this.build(data, options);\n\n        try {\n            // eslint-disable-next-line global-require,import/no-dynamic-require\n            return require(id);\n        } catch (e) {\n            /* istanbul ignore next */\n            if (\n                isObject(e) &&\n                hasStringProperty(e, 'code')\n            ) {\n                throw new BaseError({\n                    code: e.code,\n                    message: hasStringProperty(e, 'message') ? e.message : undefined,\n                    stack: hasStringProperty(e, 'stack') ? e.stack : undefined,\n                });\n            }\n\n            return handleException(e);\n        }\n    }\n\n    private build(\n        data: LocatorInfo | string,\n        options: ModuleLoadOptions = {},\n    ) : string {\n        if (isLocatorInfo(data) || isFilePath(data)) {\n            if (typeof data !== 'string') {\n                data = buildFilePath(data);\n            }\n\n            if (options.withFilePrefix) {\n                data = pathToFileURL(data).href;\n            }\n        }\n\n        return data;\n    }\n}\n","/*\n * Copyright (c) 2022-2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport fs from 'node:fs';\nimport { buildFilePath } from '../../../locator';\nimport { handleException } from '../../../utils';\nimport type { Loader } from '../../type';\n\nexport class JSONLoader implements Loader {\n    async execute(input: string) {\n        const filePath = buildFilePath(input);\n\n        try {\n            const file = await fs.promises.readFile(filePath, { encoding: 'utf-8' });\n            return JSON.parse(file);\n        } catch (e) {\n            return handleException(e);\n        }\n    }\n\n    executeSync(input: string) {\n        const filePath = buildFilePath(input);\n\n        try {\n            const file = fs.readFileSync(filePath, { encoding: 'utf-8' });\n            return JSON.parse(file);\n        } catch (e) {\n            return handleException(e);\n        }\n    }\n}\n","/*\n * Copyright (c) 2022-2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { parse } from 'yaml';\nimport fs from 'node:fs';\nimport { buildFilePath } from '../../../locator';\nimport { handleException } from '../../../utils';\nimport type { Loader } from '../../type';\n\nexport class YAMLLoader implements Loader {\n    async execute(input: string) {\n        const filePath = buildFilePath(input);\n\n        try {\n            const file = await fs.promises.readFile(filePath, { encoding: 'utf-8' });\n            return parse(file);\n        } catch (e) {\n            return handleException(e);\n        }\n    }\n\n    executeSync(input: string) {\n        const filePath = buildFilePath(input);\n\n        try {\n            const file = fs.readFileSync(filePath, { encoding: 'utf-8' });\n            return parse(file);\n        } catch (e) {\n            return handleException(e);\n        }\n    }\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nexport enum LoaderId {\n    MODULE = 'module',\n    JSON = 'json',\n    CONF = 'conf',\n    YAML = 'yaml',\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport path from 'node:path';\nimport { buildFilePath, pathToLocatorInfo } from '../locator';\nimport { isFilePath } from '../utils';\nimport { ConfLoader, JSONLoader, ModuleLoader } from './built-in';\nimport { YAMLLoader } from './built-in/yaml';\nimport { LoaderId } from './constants';\nimport type { Loader, Rule } from './type';\n\nexport class LoaderManager implements Loader {\n    protected loaders : Record<string, Loader>;\n\n    protected rules : Rule[];\n\n    constructor() {\n        this.loaders = {};\n        this.rules = [\n            {\n                test: ['.js', '.mjs', '.mts', '.cjs', '.cts', '.ts'],\n                loader: LoaderId.MODULE,\n            },\n            {\n                test: ['.conf'], loader: LoaderId.CONF,\n            },\n            {\n                test: ['.json'], loader: LoaderId.JSON,\n            },\n            {\n                test: ['.yml', '.yaml'], loader: LoaderId.YAML,\n            },\n        ];\n    }\n\n    register(rule: Rule) : void;\n\n    register(test: string[] | RegExp, loader: Loader) : void;\n\n    register(test: any, loader?: Loader) : void {\n        if (typeof loader !== 'undefined') {\n            this.rules.push({ test, loader });\n            return;\n        }\n\n        this.rules.push(test);\n    }\n\n    async execute(input: string) : Promise<any> {\n        const id = this.findLoader(input);\n        if (!id) {\n            const info = pathToLocatorInfo(input);\n            throw new Error(`No loader registered for extension: \"${info.extension}\"`);\n        }\n\n        const loader = this.resolve(id);\n        return loader.execute(input);\n    }\n\n    executeSync(input: string) : any {\n        const id = this.findLoader(input);\n        if (!id) {\n            const info = pathToLocatorInfo(input);\n            throw new Error(`No loader registered for extension: ${info.extension || 'unknown'}`);\n        }\n\n        const loader = this.resolve(id);\n        return loader.executeSync(input);\n    }\n\n    findLoader(input: string) : Loader | string | undefined {\n        if (!isFilePath(input)) {\n            return LoaderId.MODULE;\n        }\n\n        const info = pathToLocatorInfo(input);\n        for (let i = 0; i < this.rules.length; i++) {\n            const { test } = this.rules[i] as Rule;\n            if (Array.isArray(test)) {\n                if (\n                    info.extension &&\n                    test.indexOf(info.extension) !== -1\n                ) {\n                    return this.rules[i].loader;\n                }\n            } else if (test.test(buildFilePath(info))) {\n                return this.rules[i].loader;\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Resolve loader by id.\n     *\n     * @param id\n     */\n    resolve(id: string | Loader) : Loader {\n        if (typeof id !== 'string') {\n            return id;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(this.loaders, id)) {\n            return this.loaders[id] as Loader;\n        }\n\n        let loader : Loader | undefined;\n\n        // built-in\n        switch (id) {\n            case LoaderId.CONF: {\n                loader = new ConfLoader();\n                break;\n            }\n            case LoaderId.MODULE: {\n                loader = new ModuleLoader();\n                break;\n            }\n            case LoaderId.JSON: {\n                loader = new JSONLoader();\n                break;\n            }\n            case LoaderId.YAML: {\n                loader = new YAMLLoader();\n                break;\n            }\n            /* istanbul ignore next */\n            default: {\n                const pluginPath = this.normalizePath(id);\n                const moduleLoader = this.resolve(LoaderId.MODULE);\n                loader = moduleLoader.executeSync(pluginPath);\n\n                break;\n            }\n        }\n\n        if (typeof loader !== 'undefined') {\n            this.loaders[id] = loader;\n\n            return loader;\n        }\n\n        throw new Error(`The loader ${id} could not be resolved.`);\n    }\n\n    /* istanbul ignore next */\n    normalizePath(input: string) {\n        if (path.isAbsolute(input) || input.startsWith('./')) {\n            return input;\n        }\n\n        if (input.startsWith('module:')) {\n            return input.substring(0, 'module:'.length);\n        }\n\n        if (!input.startsWith('@')) {\n            return `@locter/${input}`;\n        }\n\n        return input;\n    }\n}\n","/*\n * Copyright (c) 2023.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { LoaderManager } from './module';\n\nlet instance : LoaderManager;\nexport function useLoader() {\n    if (typeof instance !== 'undefined') {\n        return instance;\n    }\n\n    instance = new LoaderManager();\n\n    return instance;\n}\n","/*\n * Copyright (c) 2022.\n * Author Peter Placzek (tada5hi)\n * For the full copyright and license information,\n * view the LICENSE file that was distributed with this source code.\n */\n\nimport { buildFilePath } from '../locator';\nimport type { LocatorInfo } from '../locator';\nimport { useLoader } from './singleton';\nimport type { Loader, Rule } from './type';\n\nexport function registerLoader(rule: Rule) : void;\nexport function registerLoader(test: string[] | RegExp, loader: Loader) : void;\nexport function registerLoader(test: any, loader?: Loader) : void {\n    const manager = useLoader();\n    if (typeof loader !== 'undefined') {\n        manager.register(test, loader);\n\n        return;\n    }\n\n    manager.register(test);\n}\n\nexport async function load(input: LocatorInfo | string) : Promise<any> {\n    const manager = useLoader();\n    if (typeof input === 'string') {\n        return manager.execute(input);\n    }\n\n    return manager.execute(buildFilePath(input));\n}\n\nexport function loadSync(input: LocatorInfo | string) : any {\n    const manager = useLoader();\n    if (typeof input === 'string') {\n        return manager.executeSync(input);\n    }\n\n    return manager.executeSync(buildFilePath(input));\n}\n"],"names":["input","pattern","ignore","onlyDirectories","onlyFiles","name","extension","info","items","executeSync","parse","config","get","value","output","code","message","stack","loadSync","build","data","LoaderId","test","loader","findLoader","instance","manager"],"mappings":"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"}