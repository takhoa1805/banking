"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCassandraAsyncProviders = exports.createCassandraOptions = exports.createClientProvider = exports.createTokenProvider = void 0;
const cassandra_constants_1 = require("./cassandra.constants");
const cassandra_utils_1 = require("./cassandra.utils");
function createTokenProvider(token) {
    return {
        provide: cassandra_constants_1.CASSANDRA_TOKEN,
        useValue: token,
    };
}
exports.createTokenProvider = createTokenProvider;
function createClientProvider(token) {
    return {
        provide: (0, cassandra_utils_1.createCassandraToken)(token),
        inject: [cassandra_constants_1.CASSANDRA_OPTIONS],
        useFactory: cassandra_utils_1.createClient,
    };
}
exports.createClientProvider = createClientProvider;
function createCassandraOptions(options) {
    return {
        provide: cassandra_constants_1.CASSANDRA_OPTIONS,
        useValue: options,
    };
}
exports.createCassandraOptions = createCassandraOptions;
function createCassandraAsyncProviders(options) {
    if (options.useFactory || options.useExisting) {
        return [createCassandraAsyncOptions(options)];
    }
    const useClass = options.useClass;
    return [
        createCassandraAsyncOptions(options),
        {
            provide: useClass,
            useClass,
        },
    ];
}
exports.createCassandraAsyncProviders = createCassandraAsyncProviders;
function createCassandraAsyncOptions(options) {
    if (options.useFactory) {
        return {
            provide: cassandra_constants_1.CASSANDRA_OPTIONS,
            inject: options.inject,
            useFactory: options.useFactory,
        };
    }
    const inject = [
        (options.useClass || options.useExisting),
    ];
    return {
        provide: cassandra_constants_1.CASSANDRA_OPTIONS,
        inject,
        useFactory: async (factory) => await factory.createCassandraOptions(options.clientName),
    };
}
//# sourceMappingURL=cassandra.providers.js.map